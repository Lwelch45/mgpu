
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Examples &mdash; mgpu v0.1 documentation</title>
    <link rel="stylesheet" href="static/nature.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="mgpu v0.1 documentation" href="index.html" />
    <link rel="next" title="Rationale" href="rationale.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="rationale.html" title="Rationale"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mgpu v0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#axpy-function" id="id1">axpy Function</a></li>
</ul>
</div>
<div class="section" id="axpy-function">
<h2><a class="toc-backref" href="#id1">axpy Function</a><a class="headerlink" href="#axpy-function" title="Permalink to this headline">¶</a></h2>
<p>This example illustrates how an axpy function could be implemented. The axpy
function calculates</p>
<div class="math">
<p><img src="_images/math/068a3058340ff9f690bf7b871e2240655c6976d7.png" alt="y = y + (a*x)." /></p>
</div><p>Please note
that there exists an axpy function that is based on the CUDA BLAS library. This
is an example that illustrated how all the features of the MGPU library work
together: containers, communication, kernel invocation and synchronization.</p>
<p>First up is the kernel and a thin kernel caller function. The kernel caller
takes as an argument two device ranges <tt class="docutils literal"><span class="pre">X</span></tt> and <tt class="docutils literal"><span class="pre">Y</span></tt> and a constant <tt class="docutils literal"><span class="pre">a</span></tt>. The
kernel caller calculates the correct number of threads and blocks that are
required to calculate the result. In this example the number of threads per
block is fixed to <tt class="docutils literal"><span class="pre">256</span></tt>. The number of blocks is calculated from the vector
size. The caller passes <tt class="docutils literal"><span class="pre">a</span></tt>, two raw pointers and the size of the vectors
to the kernel.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// axpy CUDA kernel code</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">axpy_kernel</span><span class="p">(</span>
  <span class="kt">float</span> <span class="k">const</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// axpy CUDA kernel launcher</span>
<span class="kt">void</span> <span class="n">axpy</span><span class="p">(</span><span class="kt">float</span> <span class="k">const</span> <span class="n">a</span><span class="p">,</span> <span class="n">dev_range</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">,</span> <span class="n">dev_range</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">Y</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">T</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span><span class="p">;</span>
  <span class="n">axpy_kernel</span><span class="o">&lt;&lt;&lt;</span> <span class="n">B</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">X</span><span class="p">.</span><span class="n">get_raw_pointer</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="n">get_raw_pointer</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The kernel itself calculates the array position <tt class="docutils literal"><span class="pre">i</span></tt> it has to work with,
checks that it is not greater than the vector size and performs the calculation.
The following section shows the main function that prepares the data and invokes
the kernel.</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="n">environment</span> <span class="n">e</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="n">ublas</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">Y</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">Y_gold</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">float</span> <span class="k">const</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">.42</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">X</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">random_number</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">Y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">random_number</span><span class="p">);</span>
    <span class="n">Y_gold</span> <span class="o">=</span> <span class="n">Y</span><span class="p">;</span>

    <span class="n">seg_dev_vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">X_dev</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">Y_dev</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_dev</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="n">copy</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Y_dev</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

    <span class="c1">// calculate on devices</span>
    <span class="n">invoke_kernel_all</span><span class="p">(</span><span class="n">axpy</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">X_dev</span><span class="p">,</span> <span class="n">Y_dev</span><span class="p">);</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">Y_dev</span><span class="p">,</span> <span class="n">Y</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">synchronize_barrier</span><span class="p">();</span>

    <span class="c1">// gold result (using boost::numeric)</span>
    <span class="n">Y_gold</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">X</span><span class="p">;</span>

    <span class="c1">// compare result</span>
    <span class="kt">bool</span> <span class="n">equal</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Y</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">equal</span> <span class="o">&amp;=</span> <span class="n">rough_eq</span><span class="p">(</span><span class="n">Y_gold</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">.0001</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test not ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>The MGPU library is compatible with
<a class="reference external" href="http://www.boost.org/doc/libs/release/libs/numeric">Boost.Numeric</a>
containers. We show the compatibility here and also use it to calculate a gold
result on the host to verify the device code. First we create the X and Y
vectors and a third vector to store the host result <tt class="docutils literal"><span class="pre">Y_gold</span></tt>. We fill the
vectors with random numbers and transfer them to equivalent segmented device
vectors <tt class="docutils literal"><span class="pre">X_dev</span></tt> and <tt class="docutils literal"><span class="pre">Y_dev</span></tt>. Note that the use of the segmented device
vector automatically distributes the vector across all devices. Next we invoke
the kernel caller. We pass the function we want to invoke and its arguments to
the <tt class="docutils literal"><span class="pre">invoke_kernel_all</span></tt> function. This will call the function for each device
in each device thread and context. The segmented device vector function
arguments are transformed to local device ranges - each range contains the
local vector. After the computation is finished we transfer the result back to
host memory and we call <tt class="docutils literal"><span class="pre">synchronize_barrier</span></tt> to make sure all operations
finished and the data was copied to host memory. We finally perform the same
computation on the host and compare the results.</p>
<p>The full code can be found in the example directory in file <tt class="docutils literal"><span class="pre">axpy.cu</span></tt>.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="rationale.html" title="Rationale"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">mgpu v0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Sebastian Schaetz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>